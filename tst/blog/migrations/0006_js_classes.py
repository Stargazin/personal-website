# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations
from django.template.defaultfilters import slugify


def load_post(apps, schema_editor):
	Topic = apps.get_model('blog', 'Topic')
	Post = apps.get_model('blog', 'Post')
	Section = apps.get_model('blog', 'Section')

	web = Topic.objects.get(name='web')
	topic = web

	post = Post(topic=topic,
		title='JavaScript Constructors, Prototypes, And Classes',
		number='4',
		date='March 13th, 2016',
		summary='How are classes created in JavaScript? JavaScript doesn\'t actually have classes (before ES6), but there are ways to create class-like behaviors. In this post, we\'ll look at how we can imitate classes in JavaScript using constructor functions and prototype objects.')
	post.save()

	section = Section(post=post,
		number='1',
		heading='Getting ready for some construction',
		content='<p>The only thing we really need to imitate a "class" is a <strong>constructor function</strong>. Let\'s create a simple <code class="inline">Fruit</code> constructor to work with for the rest of this post.</p>\n\n<p class="btw">Constructor functions are named just like other functions, except the first word is capitalized.</p>\n\n<p class="new">Below, <code class="inline">var price</code> declares a variable with no value. A value is later assigned to <code class="inline">price</code> depending on the value of <code class="inline">isLocal</code>.</p>\n\n<pre><code class="language-javascript">\nfunction Fruit(name, isLocal) {\n  this.name = name;\n  this.isLocal = isLocal;\n  this.isYummy = "usually";\n  this.price = function() {\n    var price;\n    this.isLocal ? price = "cheap" : price = "expensive";\n    return this.name + "s are " + price;\n  };\n} \n</code></pre>\n\n<p>If you\'re familiar with object-oriented progamming, what we just created will look similar to a class. In order to "instantiate our class", we have to use the keyword <code class="inline">new</code> with the <code class="inline">Fruit</code> constructor to <strong>create a new object</strong>.</p>\n\n<p class="new">While data structures like arrays are technically objects, an <em>object</em> in JavaScript is this: <code class="inline">{ property: value, ... }</code>. In other languages, these may be known as dictionaries.</p>\n\n<pre><code class="language-javascript">\nvar apple = new Fruit("apple", true);  // Assign new Fruit object to apple.\n\napple.name     // "apple"\napple.isLocal  // true\napple.isYummy  // "usually"\napple.price()  // "apples are cheap"\n</code></pre>\n\nWhat we\'ve essentially done is this:\n\n<pre><code class="language-javascript">\nvar apple = {\n  name: "apple",\n  isLocal: true,\n  isYummy: "usually",\n  price: function() {...}\n}\n</code></pre>\n\n<p class="btw">When an object is created using a constructor, the special variable <code class="inline">this</code> in the constructor function is bound to the object being created.</p>\n\n<p>Using our constructor function, we don\'t have to type all that out each time we create a new object. All we have to do is use <code class="inline">new Constructor()</code> to create a new object, and then we can assign the object to a variable.</p>\n\n<p>It\'s important to remember that we are creating are objects, so <strong>properties can be created and changed</strong>. We said a <code class="inline">Fruit</code> is <code class="inline">"usually"</code> yummy, but what about an <code class="inline">apple</code>? Apples are always yummy -- so yummy that we\'ll even grow a tree for unlimited apples.</p>\n\n<pre><code class="language-javascript">\napple.isYummy  // "usually"\napple.price()  // "apples are cheap"\n\napple.isYummy = "always!";\napple.price = "free!";\n\napple.isYummy  // "always!"\napple.price    // "free!"\n</code></pre>\n\n<p class="new">Object properties can essentially be thought of as variables, so they can be reassigned new values. The <code class="inline">price</code> property originally contained a function as a value (yes that can happen), so <code class="inline">price</code> is a <strong>method</strong>.</p>\n\n<p>Awesome. We can create as many new <code class="inline">Fruit</code> objects as we want, and they will all have the four properties defined in our constructor. There is a catch though, specifically with the properties that we aren\'t using arguments to assign values to. Every new object we create means another <code class="inline">isYummy</code> property and another <code class="inline">price</code> method for that object alone. This means a <strong>slower program</strong> that uses <strong>more memory</strong>. Let\'s see how prototypes can help us solve this problem.</p>')
	section.save()

	section = Section(post=post,
		number='2',
		heading='Feeling generous - everyone gets a prototype',
		content='<p>Prototypes can be a bit tricky. We\'ll start by figuring out what they are exactly before using the concept with constructors. <strong>A prototype is simply an object</strong> with properties and values, but prototype objects are special. When a property lookup is done on something, but that something doesn\'t have the property, JavaScript will look in its prototype(s) until the property is found or there is no where else to look. <strong>Almost everything has access to at least one prototype</strong> (ex: strings have access to <code class="inline">Object.prototype</code>). Some may have more (ex: arrays have access to <code class="inline">Array.prototype</code>, which has access to <code class="inline">Object.prototype</code>). Check out these two quick examples.</p>\n\n<pre><code class="language-javascript">\ntrue.toString() // "true"\n</code></pre>\n\n<p>Even though the boolean <code class="inline">true</code> doesn\'t have the method <code class="inline">toString</code>, the method can be found in its (only) prototype, <code class="inline">Object.prototype</code>.</p>\n\n<pre><code class="language-javascript">\n[1, 2, 3].toString() // "1,2,3"\n</code></pre>\n\n<p>For arrays, the <code class="inline">toString</code> method does something slightly different. Instead of turning a single entity into a string like in the previous example, the method turns the value of each index in the array to strings, and then concatenates them into a single string. This happens because <code class="inline">toString</code> is a also method in <code class="inline">Array.prototype</code>, so JavaScript doesn\'t even look in <code class="inline">Object.prototype</code>.</p>\n\n<p>That\'s prototypes! So how do prototypes work with constructor functions?</p>')
	section.save()

	section = Section(post=post,
		number='3',
		heading='Getting class-y with JavaScript',
		content='<p>A simple object <code class="inline">{}</code> will have access to <code class="inline">Object.prototype</code>. An object created with <code class="inline">new Constructor()</code> will have access to <code class="inline">Constructor.prototype</code> (which has access to <code class="inline">Object.prototype</code>). Therefore, our <code class="inline">apple</code> object from before will have access to the <code class="inline">Fruit.prototype</code> object, and so will all new objects created by the <code class="inline">Fruit</code> constructor. Great! Now we can solve our problem from before.</p>\n\n<p>Instead of doing this:</p>\n\n<pre><code class="language-javascript">\nfunction Fruit(name, isLocal) {\n  this.name = name;\n  this.isLocal = isLocal;\n  this.isYummy = "usually";\n  this.price = function() {...};\n}\n</code></pre>\n\n<p>We can do this:</p>\n\n<pre><code class="language-javascript">\nfunction Fruit(name, isLocal) {\n  this.name = name;\n  this.isLocal = isLocal;\n}\n\nFruit.prototype.isYummy = "usually";\nFruit.prototype.price = function() {...};\n</code></pre>\n\n<p class="btw">Remember prototypes are objects! We can add and change properties as we would any other object: <code class="inline">Foo.prototype.property = value;</code></p>\n\n<p>Now each time we create a new object using <code class="inline">Fruit</code>, we only have to create two new properties instead of four! The values that don\'t need to change <strong>exist once</strong> in <code class="inline">Fruit.prototype</code>. Let\'s make two more fruits to emphasize and reiterate a few important points.</p>\n\n<pre><code class="language-javascript">\nvar orange = new Fruit("orange", false);\n/* New properties can be created,\n * and existing properties can be changed.\n * (same goes for prototype properties) */\n\norange.isOrange = "i think?";\norange.isOrange  // "i think?"\norange.isOrange = "duh!"\norange.isOrange  // "duh!"\n\n\nvar grape = new Fruit("grape", true);\n/* Property lookups happen on the object\'s prototype(s)\n * only if they can\'t be found in the object itself. */\n\ngrape.isYummy = "no, I\'m allergic!";\nFruit.prototype.isYummy  // "usually"\ngrape.isYummy            // "no, I\'m allergic!"\n</code></pre>\n\n<p>So there we have it. We can\'t actually declare classes (unless we\'re using ES6), but <strong>we can use constructors and prototypes to create new objects as if we were instantiating a class</strong>. Now that we know how to do "classes", let\'s try subclassing!</p>\n\n<p class="new">The "ES" in ES6 stands for ECMAScript, the spec that JavaScript adheres to. ES6 is a new version that will bring lots of new/convenient features to JavaScript.</p>')
	section.save()

	section = Section(post=post,
		number='4',
		heading='Taking after our parent (classes)',
		content='<p>Since we\'re always changing <code class="inline">isYummy</code>, let\'s just make a new constructor called <code class="inline">YummyFruit</code> by <strong>"subclassing"</strong> <code class="inline">Fruit</code>.</p>\n\n<pre><code class="language-javascript">\nfunction YummyFruit(name, isLocal) {  // Pass these arguments\n  Fruit.call(this, name, isLocal);    // into here.\n  this.isDelicious = true;  // Property unique to YummyFruit objects.\n}\n\nYummyFruit.prototype = Object.create(Fruit.prototype);\nYummyFruit.prototype.isYummy = "always!";\n</code></pre>\n\n<p>That\'s it! Now we can create new <code class="inline">YummyFruit</code> objects, and in those objects, we\'ll find all the properties found in a <code class="inline">Fruit</code> object. <code class="inline">YummyFruit</code> objects will have access to <code class="inline">YummyFruit.prototype</code>, which has access to <code class="inline">Fruit.prototype</code>. That being said, it\'s important to understand that <code class="inline">YummyFruit.prototype</code> and <code class="inline">Fruit.prototype</code> are <strong>not the same object</strong>! Without getting into too much details about this concept (object mutability), here\'s a quick example that will hopefully illustrate this point.</p>\n\n<pre><code class="language-javascript">\n/* Assigned to the same prototype object */\nYummyFruit.prototype = Fruit.prototype;\n\nYummyFruit.prototype.isLarge = "maybe";\nFruit.prototype.isLarge  // "maybe"\n\nFruit.prototype.isSmall = "possibly";\nYummyFruit.prototype.isSmall  // "possibly"\n\n/*----------Different code below----------*/\n\n/* Assigned to a new prototype object with access to old prototype */\nYummyFruit.prototype = Object.create(Fruit.prototype);\n\nYummyFruit.prototype.isLarge = "maybe";\nFruit.prototype.isLarge  // undefined\n\nFruit.prototype.isSmall = "possibly";\nYummyFruit.prototype.isSmall  // "possibly"\n</code></pre>\n\n<p class="btw">Another unfamilar method is found above, the <code class="inline">call</code> method in <code class="inline">Function.prototype</code>. It essentially just lets you call the function and set the context of <code class="inline">this</code>. The most difficult part of explaining how <code class="inline">call</code> works would be explaining what <code class="inline">this</code> is in detail, which is a bit outside the scope of this post. For the context of this post, passing <code class="inline">this</code> as the first argument to call lets <code class="inline">Fruit</code> know to bind the <code class="inline">this</code> in its function body to the object being created (same general concept as before).</p>\n\n<p>There we have it: "subclassing" in JavaScript. Nice work! It\'s a lot concepts, so <strong>please let me know in the comments below</strong> if anything can be clarified or if anything worked particularly well! Before we finish, here\'s a <code class="inline">YummyFruit</code> just for you.</p>\n\n<pre><code class="language-javascript">\nvar mango = new YummyFruit("mango", false);\n\n/* From YummyFruit */\nmango.isDelicious  // true\n\n/* From YummyFruit.prototype */\nmango.isYummy  // "always!"\n\n/* From Fruit (originally) */\nmango.name  // "mango"\n\n/* From Fruit.prototype */\nmango.price()  // "mangos are expensive"\n</code></pre>')
	section.save()

	if not post.title_url:
		post.title_url = slugify(post.title)
		post.save()


class Migration(migrations.Migration):

    dependencies = [
        ('blog', '0005_bem'),
    ]

    operations = [
    	migrations.RunPython(load_post),
    ]