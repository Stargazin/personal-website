# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations
from django.template.defaultfilters import slugify


def load_post(apps, schema_editor):
	Topic = apps.get_model('blog', 'Topic')
	Post = apps.get_model('blog', 'Post')
	Section = apps.get_model('blog', 'Section')

	web = Topic.objects.get(name='web')
	topic = web

	post = Post(topic=topic,
		title='Vagrant Setup With VirtualBox',
		#title_url='',
		number='1',
		date='February 1st, 2016',
		summary='Vagrant is a great tool for keeping our projects separate and happy. We can spin up as many different development environments as we need, and simply destroy them when we are done with them! In this post, we\'ll get Vagrant up and running with VirtualBox, and then take a look at how the virtual machine interacts with our own machine. Lastly, we\'ll finish off by setting up our virtual machine for development with Django.')
	post.save()

	section1 = Section(post=post,
		number='1',
		heading='Installing some software',
		content='<p>In this tutorial, we\'ll be using <a class="text-link" target="_blank" href="https://git-scm.com/downloads">Git Bash</a> for Windows and the terminal for Mac OS X and Linux.</p>\n\n<p class="new">With Git Bash, system, user, and folder information are above the <code class="inline">$</code> line. To keep things simple, I will omit the extra information. If you are using OS X or Linux, you don\'t need to download anything, but note that you will see some combination of system, user, and file location like so: <code class="inline">System:~/Folder User$</code></p>\n\n<p>Install <a class="text-link" target="_blank" href="http://vagrantup.com">Vagrant</a> and <a class="text-link" target="_blank" href="https://www.virtualbox.org">VirtualBox</a></p>\n\n<p>Choose a <a class="text-link" target="_blank" href="https://vagrantcloud.com">Vagrant box</a>. We\'ll be using the hashicorp/precise32 box in this example.</p>\n\n<pre><code class="language-bash">\n$ vagrant box add hashicorp/precise32\n</code></pre>\n\n<p>Now we can create our virtual machine!</p>\n\n<p class="btw">We may refer to the virtual machine as the VM.</p>')
	section1.save()

	section2 = Section(post=post,
		number='2',
		heading='Preparing the virtual machine',
		content='<p>Make a folder for our VM.</p>\n\n<pre><code class="language-bash">\n$ mkdir practice_folder\n$ cd practice_folder\n</code></pre>\n\n<p class="new">This folder can be located anywhere, but make sure you keep track of which folder we\'re currently in by using the <code class="inline">pwd</code> command.</p>\n\n<p>Run the following command to create a VM in our new folder.</p>\n\n<pre><code class="language-bash">\n#run only once to create our VM; a vagrantfile will also be created\n$ vagrant init hashicorp/precise32\n#check that the vagrantfile was created\n$ ls\n</code></pre>\n\n<p>Let\'s make sure our VM works!</p>\n\n<pre><code class="language-bash">\n$ vagrant up\n$ vagrant ssh\n</code></pre>\n\n<p class="btw">If Vagrant is uncooperative, try giving it administrative privileges by going to the VirtualBox application in your Program Files. Right click the application, go to properties, go under the Security tab, and change permissions by clicking "Edit". Also click "Yes" if anything pops up asking for permission when running the VM!<br><br>If that doesn\'t work, try setting the compatibility of VirtualBox to Windows 7. Again, go to the properties of the VirtualBox application. Under the Compatibility tab, check the box that says "Run this program in compatibility mode for:" and select Windows 7.<br><br>I\'m using Windows 8.1 and setting the compatibility mode solved the problems I had!</p>\n\n<p>Now that we\'re inside our VM, you should see the following:</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$\n</code></pre>\n\n<p>Let\'s go ahead and get the newest software and security packages before we make some configuration changes to our vagrantfile</p>\n\n<pre><code class="language-bash">\n#download newest packages\nvagrant@precise32:~$ sudo apt-get update\n#upgrade packages to the newest version\nvagrant@precise32:~$ sudo apt-get upgrade\n</code></pre>\n\n<p>Run the following command to get out of our VM and back to our machine!</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$ exit\n</code></pre>')
	section2.save()

	section3 = Section(post=post,
		number='3',
		heading='Configuring the vagrantfile',
		content='<p>Open up the vagrantfile for editting and look for this block.</p>\n\n<pre><code class="language-bash">\n# Create a private network, which allows host-only access to the machine\n# using a specific IP.\n# config.vm.network "private_network", ip: "192.168.33.10"\n</code></pre>\n\n<p>Uncomment the last line in that block. This lets us connect to our development environment later using the IP address in that line.</p>\n\n<pre><code class="language-bash">\n# Create a private network, which allows host-only access to the machine\n# using a specific IP.\n config.vm.network "private_network", ip: "192.168.33.10"\n </code></pre>\n\n<p class="btw">Feel free to change the IP address to something easy to remember like 33.33.33.33 !</p>\n\n<p>I also recommend uncommenting the last line of the block prior to the one above and making the changes shown below.</p>\n\n<pre><code class="language-bash">\n# Create a forwarded port mapping which allows access to a specific port\n# within the machine from a port on the host machine. In the example below,\n# accessing "localhost:8080" will access port 80 on the guest machine.\n config.vm.network "forwarded_port", guest: 8080, host: 8080\n </code></pre>\n\n<p class="btw">I couldn\'t connect to the VM server through the guest machine (our machine) unless the guest and host ports specified above were the same. Try this if you have trouble connecting to the development server later!</p>\n\n<p>We\'ll want to reload the VM whenever we make changes to the vagrantfile!</p>\n\n<pre><code class="language-bash">\n$ vagrant reload\n</code></pre>')
	section3.save()

	section4 = Section(post=post,
		number='4',
		heading='Getting familiar with the virtual machine',
		content='<p>At this point we\'ve pretty much set up everything we need to start working in our VM! In the next section, we\'ll install some packages for working with Django/Python, but first let\'s see how we\'ll be working with Vagrant.</p>\n\n<p>Vagrant works by syncing a folder in the VM with a folder on our machine. The folder on our machine is where the vagrantfile is located, and the folder on the VM is also where the vagrantfile is located. This means our vagrantfile is our first file synced between our virtual and own machines. Let\'s check it out!</p>\n\n<pre><code class="language-bash">\n$ vagrant ssh\n\nvagrant@precise32:~$\n\n#change to the /vagrant folder\nvagrant@precise32:~$ cd /vagrant\n#check for the vagrantfile\nvagrant@precise32:/vagrant$ ls\n</code></pre>\n\n<p>Open up the vagrantfile with a text editor such as nano (pre-installed).</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:/vagrant$ nano vagrantfile\n</code></pre>\n\n<p class="new">Navigate the nano editor with your arrow keys. Press Ctrl + x if you want to close the file.</p>\n\n<p>The contents of the vagrantfile in the VM is exactly the same as in our machine. Any changes we make to the vagrantfile from either location will result in a synced up vagrantfile! Let\'s see what happens when we create a file or a folder.</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:/vagrant$ mkdir test_folder\n#test_folder is in our VM\nvagrant@precise32:/vagrant$ ls\nvagrant@precise32:/vagrant$ exit\n\n#test_folder is also in our machine!\n$ ls\n$ rmdir test_folder\n#now test_folder is gone\n$ ls\n$ vagrant ssh\n\nvagrant@precise32:~$ cd /vagrant\n#test_folder is gone on the VM too!\nvagrant@precise32:/vagrant$ ls\n</code></pre>\n\n<p>As we saw in the above examples, changes we make to the files on our machine will be synced with those in the VM\'s <code class="inline">/vagrant</code> folder (and vice versa). We\'ll be using the VM as our development server. Vagrant is great for this because development environments can have very different dependencies. With a VM for each project, we will have exactly what we need for each project\'s development and no conflicts between projects!</p>')
	section4.save()

	section5 = Section(post=post,
		number='5',
		heading='Working with Django and Vagrant',
		content='<p>Now that we know how we\'ll be working with the VM, let\'s set it up so that we can actually start working with it. We will go ahead and get a virtual environment set up as well as install some packages we\'ll need to work with Django. If you aren\'t in the VM, <code class="inline">vagrant ssh</code> back in.</p>\n\n<p class="new">The concept behind virtual environments is actually very similar to that of virtual machines. Essentially, we can install packages onto a virtual environment and not have it affect the VM unless we are working on said virtual environment. If we\'re only using the VM for one project, you can argue that we don\'t need the virtual environment, but it\'s good practice to use it. Plus there are some cool things we can do with it (more on this in a future post)!</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$ sudo apt-get install python-pip\n\nvagrant@precise32:~$ sudo pip install virtualenv\n#the wrapper makes working with virtualenv easier\nvagrant@precise32:~$ sudo pip install virtualenvwrapper\n\n#show all content (including hidden with the -a flag)\nvagrant@precise32:~$ ls -a\n#open up the .bashrc file\nvagrant@precise32:~$ nano ~/.bashrc\n\n#scroll down and add the following lines to the .bashrc file:\n#virtualenv\nexport WORKON_HOME=$HOME/.virtualenvs\nsource /usr/local/bin/virtualenvwrapper.sh\n</code></pre>\n\n<p>These lines tell our system where our virtual environments should be located and where the virtual environment script (which we installed earlier with pip) is located. After making changes to our shell startup file, we\'ll need to reload the file so our changes take effect.</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$ source ~/.bashrc\n</code></pre>\n\n<p>We now have access to the virtual environment commands, so let\'s make our virtual environment and play around with it!</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$ mkvirtualenv practice\n\n#we are now on the virtualenv\n(practice)vagrant@precise32:~$ deactivate\nvagrant@precise32:~$ workon practice\n\n#show a list of our virtualenvs\n(practice)vagrant@precise32:~$ lsvirtualenv\n\n#deactivate and remove our virtualenv\n(practice)vagrant@precise32:~$ deactivate\nvagrant@precise32:~$ rmvirtualenv practice\n\nvagrant@precise32:~$ mkvirtualenv play\n(play)vagrant@precise32:~$\n</code></pre>\n\n<p>Notice how when we make a virtual environment, setuptools, pip, and wheel are installed to that environment. Take a look (make sure you\'re working on the virtual environment!).</p>\n\n<pre><code class="language-bash">\n(play)vagrant@precise32:~$ pip list\n</code></pre>\n\n<p>This list will grow as we install more to our virtual environment. Let\'s install a few more packages to get our environment ready for development!</p>\n\n<pre><code class="language-bash">\n#separate multiple packages with a space\n\n(play)vagrant@precise32:~$ sudo apt-get install python-dev libpq-dev \npostgresql postgresql-contrib libjpeg-dev\n\n(play)vagrant@precise32:~$ pip install django psycopg2 Pillow\n\n#check out our new python packages\n(play)vagrant@precise32:~$ pip list\n</code></pre>\n\n<p class="new">Note that because we are using pip (Python package manager) while working on our virtual environment, the packages we install will only be useable while working on that virtual environment. If we deactivated our virtual environment and then installed a package with pip, that package would be available globally -- we will have access to that package with or without our virtual environment.<br><br>Our apt-get installations will actually be global, so it doesn\'t make a difference if we\'re working on our virtual environment to install packages such as <code class="inline">python-dev</code>.</p>\n\n<p class="btw">I use postgreSQL for my database, but feel free to play around with other databases!</p>\n\n<p>We\'re almost there. To finish up, let\'s start a django project so we can start developing (make sure you are on the virtual environment where django is installed)!</p>\n\n<pre><code class="language-bash">\n#change to the synced folder\n(play)vagrant@precise32:~$ cd /vagrant\n(play)vagrant@precise32:/vagrant$ django-admin.py startproject blog\n</code></pre>\n\n<p class="btw">To run the server, <code class="inline">cd</code> into the folder containing <code class="inline">manage.py</code> and type the following: <code class="inline">python manage.py runserver 0.0.0.0:8080</code>. This is the port (8080) we specified in section 3.</p>\n\n<p>Now we have our project made and the packages needed to start developing. Happy coding!</p>')
	section5.save()

	section6 = Section(post=post,
		number='6',
		heading='A few things to keep in mind',
		content='<p>Remember to power off your VM when you are finished.</p>\n\n<pre><code class="language-bash">\nvagrant@precise32:~$ exit\n$ vagrant halt\n</code></pre>\n\n<p class="btw">I\'ve had problems with my VM getting corrupted or something along those lines. I don\'t know the exact cause, but I believe it happens when I forget to power off my VM. If this happens to you, don\'t worry! It\'s much easier to set up a second time because you won\'t need to install software and configure the vagrantfile.</p>\n\n<p>To remove a VM (whether you don\'t need it anymore or if it\'s corrupted), use the following command</p>\n\n<pre><code class="language-bash">\n$ vagrant destroy\n</code></pre>\n\n<p class="new">You can also do this manually using the Oracle VM VirtualBox application.</p>\n\n<p>If you are new to Unix shells, it can be a little intimidating navigating using commands. Here\'s a helpful command to keep track of where you are in the VM.</p>\n\n<pre><code class="language-bash">\n#pwd = print working directory (current folder)\nvagrant@precise32:~$ pwd\nvagrant@precise32:~$ cd /vagrant\nvagrant@precise32:/vagrant$ pwd\n</code></pre>\n\n<p class="new">Notice how your two results are <code class="inline">/home/vagrant</code> and <code class="inline">/vagrant</code>. These are entirely different folders!</p>')
	section6.save()

	if not post.title_url:
		post.title_url = slugify(post.title)
		post.save()


class Migration(migrations.Migration):

    dependencies = [
        ('blog', '0002_topics'),
    ]

    operations = [
    	migrations.RunPython(load_post),
    ]